 In this section, we describe the language and logic of the second-order predicate calculus. We then extend this calculus with the classical comprehension principle for concepts and we introduce and explain \(\lambda\)-notation, which allows one to turn open formulas into complex names of concepts. Although Frege’s own logic is rather different from the modern second-order predicate calculus, the latter’s comprehension principle for concepts and \(\lambda\)-notation provide us with a logically perspicuous way of representing Frege’s Theorem. We shall sometimes remark on the differences between the calculus presented below and the calculus that Frege developed, but such remarks are not intended to be a scholarly guide to the many subtleties involved in understanding Frege’s original works. The language of the second-order predicate calculus starts with the following lists of simple terms: The object names and variables denote, or take values in, a domain of objects and the \(n\)-place relation names and variables denote, or take values in, a domain of \(n\)-place relations. Objects and relations are to be regarded as mutually exclusive domains: no object is a relation and no relation is an object. When giving examples of \(n\)-place relation names or variables for \(n\geq 2\), we often write \(R, S,\ldots\) instead of writing \(P^2,Q^2,\ldots\). From these simple terms, one can define the formulas of the language as follows: So, for example, \(Pa\), \(Rxy\), etc., are atomic formulas and these assert, respectively, that object \(a\) exemplifies the 1-place relation \(P\) and that \(x\) and \(y\) stand in the relation \(R\). The formulas \(\neg Pa\) and \(Pa \to Rxy\) are molecular formulas, and these assert, respectively, that it is not the case that \(a\) exemplifies \(P\), and that if \(a\) exemplifies \(P\) then \(x\) and \(y\) stand in the relation \(R\). Finally, here are some examples of quantified formulas: The language we defined above is second-order because the last clause in the definition of the formulas sanctions both quantified formulas of the form \(\forall x\phi\) and of the form \(\forall F\phi\). In what follows, we employ the standard definitions of the following formulas: The first of the above defines the conjunction \(\phi\) and \(\psi\); the second defines the disjunction \(\phi\) or \(\psi\); the third defines the biconditional \(\phi\) if and only if \(\psi\) (which we often abbreviate as iff); and the last defines the existentially quantified formula there is an \(\alpha\) such that \(\phi\). It should be noted here that instead of using a linear string of symbols to express molecular and quantified formulas, Frege developed a two-dimensional notation for such formulas. Since we won’t be using Frege’s notation for complex formulas in what follows, we need not spend time describing it  here.[1] But even if we put aside Frege’s notation for complex formulas, it is important to point out that Frege didn’t use atomic formulas of the form \(Px\), \(Rxy\), etc., as we have done. Instead of including \(n\)-place relation names and variables among his primitive terms, he included primitive function names and variables such as \(f\), \(g\), \(h\), …, and used them to signify functions. That is, instead of distinguishing objects and relations, Frege distinguished objects from functions. Though some developments of the modern predicate calculus include function terms among the simple terms of the language, we have not included them because we shall not need them in the development of Frege’s Theorem. It is also important to point out that Frege used functional application ‘\(f(x)\)’ to form complex names in his language and used these names to represent natural language statements. To see how, note that Frege would use the expression ‘\(f(x)\)’ to denote the value of the function \(f\) for the argument \(x\). Since he also recognized two special objects he called truth-values (The True and The False), he defined a concept to be any function that always maps its arguments to truth-values. For example, whereas ‘\(x^{2} +3\)’ and ‘father-of \(x\)’ signify ordinary functions, the expressions ‘\(x\) is happy’ (which we might represent as ‘\(Hx\)’) and ‘\(x \gt 5\)’ signify concepts. The former signifies a concept which maps any object that is happy to The True and all other objects to The False; the latter signifies a concept that maps any object that is greater than 5 to The True and all other objects to The False. In this way, ordinary language predications like ‘\(b\) is happy’ and ‘4 is greater than 5’, once represented in Frege’s language as ‘\(Hb\)’ and ‘\(4 \gt 5\)’, become names of truth-values. For the purposes of understanding Frege’s Theorem, we can think of our 1-place relation terms as denoting, or ranging over, Fregean concepts. Once we do this, we can take the formula ‘\( Hb\)’ to mean that \(b\) falls under the concept being happy. But for the purposes of understanding Frege’s Theorem, it is not necessary to suppose, with Frege, that concepts like being happy are functions from objects to truth values. So, in what follows, one should remember that whereas we can interpret the atomic formula \(Fx\) to mean either that \(x\) exemplifies the 1-place relation (i.e., property) \(F\) or that \(x\) falls under the concept \(F\), Frege would understand such formulas as instances of functional application. Nevertheless, we’ll henceforth call 1-place relations concepts. For all practical purposes then, we may use the symbols \(F\), \(G\), … as variables ranging over concepts and though we sometimes write ‘\(F(x)\)’ instead of ‘\(Fx\)’ for perspicuity in parsing an expression, we should still think of this as a predication. Frege also supposed that when a binary function \(f\) (i.e., a function of two arguments) always maps the arguments \(x\) and \(y\) to a truth value, \(f\) is a relation. So it should be remembered that when we use the expression ‘\(Rxy\)’ (or sometimes ‘\(R(x,y)\)’) to assert that the objects \(x\) and \(y\) stand in the relation \(R\), Frege would say that \(R\) maps the pair of objects \(x\) and \(y\) (in that order) to The True. But again, this Fregean interpretation is not required for understanding Frege’s Theorem. In what follows, we shall sometimes write the symbol that denotes a mathematical relation in the usual ‘infix’ notation; for example, ‘\(\gt\)’ denotes the greater-than relation in the expression ‘\(x \gt y\)’. Finally, it is important to mention that one can add the following clause to the definition of the formulas of our second-order language so as to include formulas that express identity claims: Thus, formulas such as ‘\(x = y\)’ are part of the second-order predicate calculus with identity. Frege, too, had primitive identity statements; for him, identity is a binary function that maps a pair of objects to The True whenever those objects are the same object. So whereas we shall suppose that statements like ‘\(2^{2} = 4\)’ are simply true assertions and statements like ‘\(2^{2} = 3\)’ are simply false ones, Frege took ‘\(2^{2} = 4\)’ to be a name of The True and took ‘\(2^{2} = 3\)’ to be a name of The False. The statement form ‘\(f(x) = y\)’ plays an important role in Frege’s axioms and definitions, but we shall not need to assert claims of this form in order to derive Frege’s Theorem. Instead, we shall assume (a) that identity is simply a 2-place relation and (b) that a unary function \(f\) is really a relation \(R\) that has the following property: \(Rxy \amp Rxz \to y = z\) (i.e., that functions are relations that always relate their first argument to at most one second argument). We may call such relations functional relations. In other words, when Frege asserts \( f(x) = y\), we may represent this as asserting that \(f\) is a functional relation \(R\) such that \(Rxy\). This generalizes to \( n\)-place relations for \(n\geq2\). For example, where \(+\) is the binary addition function of arithmetic, we may represent the arithmetic statement \(2+3 = 5\) in our language as a claim of the form \(+(2,3,5)\), where \(+\) is taken to be a 3-place functional relation that obeys the condition: \(+(x,y,z) \amp +(x,y,w) \to z = w\). The basic axioms and rules of inference governing statements in our second-order language are similar to those of the first-order predicate calculus with identity, though they’ve been extended to apply to claims involving universal quantifiers binding relation variables. Where \(\phi\), \(\psi\), and \(\chi\) are any formulas, \(\alpha\) any variable and \(\tau\) any term of the same type as \(\alpha\) (i.e., both are object terms or both are \(n\)-place relation terms), then the following are the basic axioms and rules of second-order logic: In what follows, we shall assume familiarity with the above axioms and rules as we derive Frege’s Theorem. As noted, these are essentially the same as the axioms for the first-order predicate calculus, except for the addition of laws for the second-order quantifiers \(\forall F\) and \(\exists F\) that correspond to the laws governing the first-order quantifiers \(\forall x\) and \(\exists x\). Some of the above laws are found explicitly in Gg I, though expressed in Frege’s notation. For example, in Gg I, §47, we find Frege’s versions of the following: These are first introduced, however, in Gg I, §§18, 20, 25, and 20, respectively. Though Frege essentially had a second-order logic in Gg, his rules of inference don’t look as familiar, or as simple, as MP and GEN. The reason is that Frege’s rules of inference govern not only his graphical notation for molecular and quantified formulas, but also his special purpose symbols, such as certain lowercase letters used as placeholders, certain Gothic letters and letters used as bound variables, and various other signs of his system we have not yet mentioned. Since Frege’s notation for rules of inference will play no role in the discussion that follows, we shall again simplify our task by not describing it further. The modern second-order predicate calculus includes a comprehension principle that effectively guarantees that there exists an \(n\)-place relation corresponding to every open formula with \(n\) free object variables \(x_1,\ldots,x_n\). We introduce this principle by considering the following 1-place case: Comprehension Principle for Concepts:  \(\exists G \forall x(Gx \equiv \phi)\),  where \(\phi\) is any formula in which \(G\) doesn't occur free. Similarly the following is a Comprehension Principle for 2-place Relations: Comprehension Principle for 2-place Relations:  \(\exists R\forall x\forall y(Rxy \equiv \phi)\),  where \(\phi\) is any formula in which \(R\) doesn't occur free. Although Frege didn’t explicitly formulate these comprehension principles, they are derivable in his system and constitute very important generalizations within his system that reveal its underlying theory of concepts and relations. We can see these principles at work by formulating the following instance of comprehension, where ‘\(Ox\)’ asserts that \(x\) is odd: \(\exists G\forall x(Gx \equiv (Ox \amp x \gt 5))\) This asserts: there exists a concept \(G\) such that for every object \(x\), \(x\) falls under \(G\) if and only if \(x\) is odd and greater than 5. If our second-order language were extended to include the primitive predicates ‘\(O\)’ and ‘\(\gt\)’ and the primitive object term ‘5’, then the above instance of the Comprehension Principle for Concepts would be an axiom (and hence, theorem) of second-order logic. Similarly, the following is an instance of the Comprehension Principle for Relations: \(\exists R\forall x\forall y(Rxy \equiv (Ox \amp x \gt y))\) This asserts the existence of a relation that objects \(x\) and \( y\) bear to one another just in case the complex condition \(Ox \amp x \gt y\) holds. Logicians nowadays typically distinguish the open formula \(\phi\) in which the variable \(x\) is free from the corresponding name of a concept. For example, they use the notation \([\lambda x \, Ox \amp x \gt 5]\) as the name of the complex concept being an \(x\) such that \(x\) is odd and \(x\) is greater than 5 (or, more naturally, ‘being odd and greater than 5’). The term-forming operator \(\lambda x\) (which we read as ‘being an \(x\) such that’) combines with a formula \(\phi\) in which \(x\) is free to produce \([\lambda x\,\phi]\). The \(\lambda\)-expression is a name of the concept expressed by the formula \(\phi\). In what follows, the scope of the variable-binding operator \(\lambda x\) in \([\lambda x\,\phi]\) applies to the entire formula \(\phi\), no matter how complex, so that instead of writing, for example, \([\lambda x\,(Ox \amp x \gt 5)]\), we shall simply write: \([\lambda x\, Ox \amp x \gt 2]\). This notation can be extended for relations. The expression: \([\lambda xy \, Ox \amp x \gt y]\) names the 2-place relation being an \(x\) and \(y\) such that \(x\) is odd and \(x\) is greater than \(y\). It is important to emphasize that Frege didn’t use \(\lambda\)-notation. By contrast, he thought that predicative expressions such as ‘(\(\, )\) is happy’ are incomplete expressions and that the concepts they denoted were unsaturated. We need not discuss Frege’s reasons for this in this entry, though interested readers may consult his 1892 essay “Concept and Object”. For the purposes of understanding Frege’s Theorem, we only need to introduce one axiom that governs \(\lambda\)-notation, namely, the principle known as \(\lambda \)-Conversion. Let \(\phi\) be any formula and let \(\phi^y_x\) be the result of substituting the variable \(y\) for free occurrences of \(x\) everywhere in \(\phi\). Then the principle of \(\lambda\)-Conversion is: \(\lambda\)-Conversion:  \(\forall y([\lambda x \, \phi]y \equiv \phi^y_x)\) This asserts: for any object \(y\), \(y\) falls under the concept \([\lambda x \, \phi]\) if and only if \(y\) is such that \(\phi^y_x\). So, using our example, the following is an instance of \(\lambda\)-conversion: \(\forall y([\lambda x \, Ox \amp x \gt 5]y \equiv Oy \amp y \gt 5)\) This asserts: for any object \(y\), \(y\) falls under the concept being odd and greater than 5 if and only if \(y\) is odd and greater than 5. Note that when the quantified variable \(y\) is instantiated to some object term, the resulting instance of \(\lambda\)-Conversion is a biconditional. Thus, among the many consequences of this axiom we find: 6 falls under the concept being odd and greater than 5 if and only if 6 is odd and greater than 5 (in this case, the biconditional remains true because both sides are false). Some logicians call the rule of inference derived from the right-to-left direction of such biconditionals ‘\(\lambda\)-Abstraction’. For example, the inference from the premise: \(O6 \amp 6 \gt 5\) to the conclusion: \([\lambda x \, Ox \amp x \gt 5]6\) is justified by \(\lambda\)-Abstraction. (Here we have a case of a valid inference in which both the premise and the conclusion are both false.) The principle of \(\lambda\)-Conversion can be generalized, so that it governs \(n\)-place \(\lambda\)-expressions as well. Here is the 2-place case: \(\forall z\forall w([\lambda xy\, \phi]zw \equiv \phi^{z,w}_{x,y})\) (In this formula \(\phi^{z,w}_{x,y}\) is the result of simultaneously substituting \(z\) for \(x\) and \(w\) for \(y\) in \(\phi\).) The reader should construct an instance of this principle using our example \([\lambda xy \, Ox \amp x \gt y]\). It should be noted at this point that instead of using comprehension principles, Frege had a distinguished rule in his system that is equivalent to such principles, namely, his Rule of Substitution. Though Frege’s Rule of Substitution allowed him to substitute formulas \(\phi\) for free concept variables \(F\) in theorems of logic, we can understand this rule in terms of the second-order logic we’ve defined as follows: in any theorem of logic with a free variable \(F^{n}\), one may both substitute any \(n\)-place \(\lambda\)-expression \([\lambda x_{1}\ldots x_{n}\, \phi]\) for \(F^{n}\) and then perform \(\lambda\)-conversion. For example, in the second-order system we now have, one can infer \(\forall x(Ox \amp x \gt 5 \equiv Ox \amp x \gt 5)\) from \(\forall y(Fy \equiv Fy)\) by first substituting \([\lambda x \, Ox \amp x \gt 5]\) for \(F\) and then using \(\lambda\)-Conversion on all the resulting subformulas containing the \(\lambda\)-expression that flank the \(\equiv\) sign. Frege’s Rule of Substitution allows one to do all this in one step. Readers interested in learning a bit more about the connection between the Rule of Substitution and Comprehension Principles described above can consult the following supplementary document: Frege’s Rule of Substitution Finally, it is important to point out that the system we have just described, i.e., second-order logic with identity and comprehension principles, extended with \(\lambda\)-expressions and \(\lambda\)-Conversion, is consistent. Its axioms are true even in very small interpretations, e.g., ones in which the domain of objects contains a single object and each domain of \(n\)-place relations \( (n\geq1)\) has just two relations. For example, if the domain of objects contains a single object, say b, and the domain of 1-place relations contains two concepts (i.e., one which b falls under and one which nothing falls under), then all of the above axioms are true, including the Comprehension Principle for Concepts and 1-place \(\lambda\)-Conversion. Even so, the system described above requires that every concept has a negation, every pair of concepts has a conjunction, every pair of concepts has a disjunction, etc. The reader should be able to write down instances of the comprehension principle which demonstrate these claims. Readers whose main goal is to understand Frege’s Theorem can now skip directly to Section 3.