 As has been noted several times earlier, formal intensional logics have been developed with a full hierarchy of higher types, Church,  Montague, Bressan, Tichý for instance. Such logics can be rather formidable, but Carnap’s ideas are often (certainly not always) at the heart of such logics, these ideas are simple, and are sufficient to allow discussion of several common intensional problems. Somehow, based on its sense (intension, meaning) a designating phrase may designate different things under different conditions—in different states. For instance, “the number of the planets” was believed to designate 6 in ancient times (counting Earth). Immediately after the discovery of Uranus in 1781 “the number of the planets” was believed to designate 7. If we take as epistemic states of affairs the universe as conceived by the ancients, and the universe as conceived just after 1781, in one state “the number of the planets” designates 6 and in the other it designates 7. In neither state were people wrong about the concept of planet, but about the state of affairs constituting the universe. If we suppress all issues of how meanings are determined, how meanings in turn pick out references, and all issues of what counts as a possible state of affairs, that is, if we abstract all this away, the common feature of every designating term is that designation may change from state to state—thus it can be formalized by a function from states to objects. This bare-bones approach is quite enough to deal with many otherwise intractable problems. In order to keep things simple, we do not consider a full type hierarchy—first-order is enough to get the basics across. The first-order fragment of the logic of Gallin 1975 would be sufficient, for instance. The particular formulation presented here comes from Fitting 2004, extending Fitting and Mendelsohn 1998. Predicate letters are intensional, as they are in every version of Kripke-style semantics, with interpretations that depend on possible worlds. The only other intensional item considered here is that of individual concept—formally represented by constants and variables that can designate different objects in different possible worlds. The same ideas can be extended to higher types, but what the ideas contribute can already be seen at this relatively simple level. Intensional logics often have nothing but intensions—extensions are inferred but are not explicit. However, an approach that is too minimal can make life hard, so consequently here we explicitly allow both objects and individual concepts which range over objects. There are two kinds of quantification, over each of these sorts. Both extensional and intensional objects are first-class citizens. Basic ideas are presented semantically rather than proof-theoretically, though both axiom systems and tableau systems exist. Even so, technical details can become baroque, so as far as possible, we will separate informal presentation, which is enough to get the general idea, from its formal counterpart, which is of more specialized interest. A general acquaintance with modal logic is assumed (though there is a very brief discussion to establish notation, which varies some from author to author). It should be noted that modal semantics is used here, and generally, in two different ways. Often one has a particular Kripke model in mind, though it may be specified informally. For instance, we might consider a Kripke model in which the states are the present instant and all past ones, with later states accessible from earlier ones. Such a model is enlightening when discussing “the King of France” for instance, even though the notion of instant is somewhat vaguely determined. But besides this use of informally specified concrete models, there is formal Kripke semantics which is a mathematically precise thing. If it is established that something, say \(\Box (X \supset Y) \supset (\Box X \supset \Box Y)\), is valid in all formal Kripke models, we can assume it will be so in our vaguely specified, intuitive models, no matter how we attempt to make them more precise. Informal models pervade our discussions—their fundamental properties come from the formal semantics. A propositional language is built up from propositional letters, \(P, Q,\ldots\), using  \(\wedge ,   \vee , \supset , \neg\) and other propositional connectives, and \(\Box\) (necessary) and \(\Diamond\) (possible) as modal operators. These operators can be thought of as alethic, deontic, temporal, epistemic—it will matter which eventually, but it does not at the moment. Likewise there could be more than one version of \(\Box\), as in a logic of knowledge with multiple knowers—this too doesn’t make for any essential differences. Kripke semantics for propositional modal logic is, by now, a very familiar thing. Here is a quick presentation to establish notation, and to point out how one of Frege’s proposals fits in. A more detailed presentation can be found in the article on modal logic in this encyclopedia. A model consists of a collection of states, some determination of which states are relevant to which, and also some specification of which propositional letters hold at which of these states. States could be states of the real world at different times, or states of knowledge, or of belief, or of the real world as it might have been had circumstances been different. We have a mathematical abstraction here. We are not trying to define what all these states might ‘mean,’ we simply assume we have them. Then more complex formulas are evaluated as true or false, relative to a state. At each state the propositional connectives have their customary classical behavior. For the modal operators. \(\Box X\), that is, necessarily \(X\), is true at a state if \(X\) itself is true at every state that is relevant to that state (at all accessible states). Likewise \(\Diamond X\), possibly \(X\), is true at a state if \(X\) is true at some accessible state. If we think of things epistemically, accessibility represents compatibility, and so \(X\) is known in a state if \(X\) is the case in all states that are compatible with that state. If we think of things alethically, an accessible state can be considered an alternate reality, and so \(X\) is necessary in a state if \(X\) is the case in all possible alternative states. These are, by now, very familiar ideas. A frame is a structure \(\langle \bG, \bR\rangle\), where \(\bG\) is a non-empty set and \(\bR\) is a binary relation on \(\bG\). Members of \(\bG\) are states (or possible worlds). \(\bR\) is an accessibility relation. For \(\Gamma , \Delta \in \bG, \Gamma \bR \Delta\) is read “\(\Delta\) is accessible from \(\Gamma\).” A (propositional) valuation on a frame is a mapping, \(\bV\), that assigns to each propositional letter a mapping from states of the frame to truth values, true or false. For simplicity, we will abbreviate \(\bV(P)(\Gamma )\) by \(\bV(P, \Gamma )\). A propositional model is a structure  \(\cM = \langle \bG, \bR, \bV\rangle\), where \(\langle \bG, \bR\rangle\) is a frame and \(\bV\) is a propositional valuation on that frame. Given a propositional model   \(\cM = \langle \bG, \bR, \bV\rangle\), the notion of formula \(X\) being true at state \(\Gamma\) will be denoted  \(\cM,   \Gamma \vDash X\), and is characterized by the following standard rules, where \(P\) is atomic. Suppose we think about formulas using an intensional/extensional distinction. Given a model \(\cM\), to each formula \(X\) we can associate a function, call it \(f_{X}\), mapping states to truth values, where we set \(f_{X}(\Gamma )\) = true just in case \(\cM, \Gamma \vDash X\). Think of the function \(f_{X}\) as the intensional meaning of the formula \(X\)—indeed, think of it as the proposition expressed by the formula (relative to a particular model, of course). At a state \(\Gamma\),  \(f_{X}(\Gamma )\) is a truth value—think of this as the extensional meaning of \(X\) at that state. This is a way of thinking that goes back to Frege, who concluded that the denotation of a sentence should be a truth value, but the sense should be a proposition. He was a little vague about what constituted a proposition—the formalization just presented provides a natural mathematical entity to serve the purpose, and was explicitly proposed for this purpose by Carnap. It should be clear that the mathematical structure does, in a general way, capture some part of Frege’s idea. Incidentally we could, with no loss, replace the function \(f_{X}\) on states with the set \(\{ \Gamma \in \bG \mid f_{X}(\Gamma) = \textit{true}\}\). The function \(f_{X}\) is simply the characteristic function of this set. Sets like these are commonly referred to as propositions in the modal logic community. In a technical sense, then, Frege’s ideas on this particular topic have become common currency. First we discuss some background intuitions, then introduce a formal semantics. Intensions will be introduced formally in Section 3.3. The material discussed here can be found more fully developed in (Fitting and Mendelsohn 1998, Hughes and Cresswell 1996), among other places. If we are to think of an intension as designating different things under different circumstances, we need things. At the propositional level truth values play the role of things, but at the first order level something more is needed. In classical logic each model has a domain, the things of that model, and quantifiers are understood as ranging over the members of that domain. It is, of course, left open what constitutes a thing—any collection of any sort can serve as a domain. That way, if someone has special restrictions in mind because of philosophical or mathematical considerations, they can be accommodated. It follows that the validities of classical logic are, by design, as general as possible—they are true no matter what we might choose as our domain, no matter what our things are. A similar approach was introduced for modal logics in Kripke 1963. Domains are present, but it is left open what they might consist of. But there is a complication that has no classical counterpart: in a Kripke model there are multiple states. Should there be a single domain for the entire model, or separate domains for each state? Both have natural intuitions. Consider a version of Kripke models in which a separate domain is associated with each state of the model. At each state, quantifiers are thought of as ranging over the domain associated with that state. This has come to be known as an actualist semantics. Think of the domain associated with a state as the things that actually exist at that state. Thus, for example, in the so-called real world the Great Pyramid of Khufu is in the domain, but the Lighthouse of Alexandria is not. If we were considering the world of, say, 1300, both would be in the domain. In an actualist approach, we need to come to some decision on what to do with formulas containing references to things that exist in other states but not in the state we are considering. Several approaches are plausible; we could take such formulas to be false, or we could take them to be meaningless, for instance, but this seems to be unnecessarily restrictive. After all, we do say things like “the Lighthouse of Alexandria no longer exists,” and we think of it as true. So, the formal version that seems most useful takes quantifiers as ranging over domains state by state, but otherwise allows terms to reference members of any domain. The resulting semantics is often called varying domain as well as actualist. Suppose we use the actualist semantics, so each state has an associated domain of actually existing things, but suppose we allow quantifiers to range over the members of any domain, without distinction, which means quantifiers are ranging over the same set, at every state. What are the members of that set? They are the things that exist at some state, and so at every state they are the possible existents—things that might exist. Lumping these separate domains into a single domain of quantification, in effect, means we are quantifying over possibilia. Thus, a semantics in which there is a single domain over which quantifiers range, the same for every state, is often called possibilist semantics or, of course, constant domain semantics. Possibilist semantics is simpler to deal with than the actualist version—we have one domain instead of many for quantifiers to range over. And it turns out that if we adopt a possibilist approach, the actualist semantics can be simulated. Suppose we have a single domain of quantification, possibilia, and a special predicate, \(E\), which we think of as true, at each state, of the things that actually exist at that state. If \(\forall\) is a quantifier over the domain of possibilia, we can think of the relativized quantifier, \(\forall\)x\((E(x) \supset \ldots )\) as corresponding to actualist quantification. (We need to assume that, at each state, \(E\) is true of something—this corresponds to assuming domains are non-empty.) This gives an embedding of the actualist semantics into the possibilist one, a result that can be formally stated and proved. Here possibilist semantics will be used, and we assume we have an existence predicate \(E\) available. The language to be used is a straightforward first order extension of the propositional modal language. There is an infinite list of object variables, \(x, y, x_{1}, x_{2},\ldots\), and a list of relation symbols, \(R, P, P_{1}, P_{2},\ldots\), of all arities. Among these is the one-place symbol \(E\) and the two-place symbol =. Constant and function symbols could be added, but let’s keep things relatively simple, along with simply relative. If \(x_{1}, \ldots ,x_{n}\) are object variables and \(P\) is an \(n\)-place relation symbol, \(P(x_{1}, \ldots ,x_{n})\) is an atomic formula. We’ll write \(x = y\) in place of = (x,y). More complex formulas are built up using propositional connectives, modal operators, and quantifiers, \(\forall\) and \(\exists\), in the usual way. Free and bound occurrences of variables have the standard characterization. A first order model is a structure \(\langle \bG, \bR, \bD_{O}, \bI\rangle\) where \(\langle \bG, \bR\rangle\) is a frame, as in Section 3.1, \(\bD_{O}\) is a non-empty object domain, and \(\bI\) is an interpretation that assigns to each \(n\)-place relation symbol \(P\) a mapping, \(\bI(P)\) from \(\bG\) to subsets of \(\bD_{O}^{n}\). We’ll write \(\bI(P, \Gamma )\) as an easier-to-read version of \(\bI(P)(\Gamma )\). It is required that \(\bI(=, \Gamma )\) is the equality relation on \(\bD_{O}\), for every state \(\Gamma\), and \(\bI(E, \Gamma )\) is non-empty, for every \(\Gamma\). A first-order valuation in a model is a mapping \(v\) that assigns a member of \(\bD_{O}\) to each variable. Note that first order valuations are not state-dependent in the way that interpretations are. A first order valuation \(w\) is an \(x\)-variant of valuation \(v\) if \(v\) and \(w\) agree on all variables except possibly for \(x\). Truth, at a state \(\Gamma\) of a model \(\cM = \langle \bG, \bR, \bD_{O}, \bI\rangle\), with respect to a first order valuation \(v\), is characterized as follows, where \(P(x_{1}, \ldots ,x_{n})\) is an atomic formula: Call a formula valid if it is true at every state of every first order model with respect to every first-order valuation, as defined above. Among the validities are the usual modal candidates, such as \(\Box (X \supset Y) \supset (\Box X \supset \Box Y)\), and the usual quantificational candidates, such as \(\forall xX \supset \exists xX\). We also have mixed cases such as the Barcan and converse Barcan formulas: \(\forall x\Box X \equiv \Box \forall xX\), which are characteristic of constant domain models, as was shown in Kripke 1963. Because of the way equality is treated, we have the validity of both \(\forall x\forall y(x = y \supset \Box x = y)\) and \(\forall x\forall y(x \ne y \supset \Box x \ne y)\). Much has been made about the identity of the number of the planets and 9 (Quine 1963), or the identity of the morning star and the evening star (Frege 1892), and how these identities might behave in modal contexts. But that is not really a relevant issue here. Phrases like “the morning star” have an intensional aspect, and the semantics outlined so far does not take intensional issues into account. As a matter of fact, the morning star and the evening star are the same object and, as Gertrude Stein might have said, “an object is an object is an object.” The necessary identity of a thing and itself should not come as a surprise. Intensional issues will be dealt with shortly. Quantification is possibilist—domains are constant. But, as was discussed in Section 3.2.1, varying domains can be brought in indirectly by using the existence predicate, \(E\), and this allows us to introduce actualist quantification definitionally. Let \(\forall^{E}xX\) abbreviate \(\forall x(E(x) \supset X)\), and let \(\exists^{E}xX\) abbreviate \(\exists x(E(x)  \wedge X)\). Then, while  \(\forall x\phi (x) \supset \phi (y)\) is valid, assuming \(y\) is free for \(x\) in \(\phi (x)\), we do not have the validity of \(\forall^{E}x\phi (x) \supset \phi (y)\). What we have instead is the validity of \([\forall^{E}x\phi (x)  \wedge E(y)] \supset \phi (y)\). As another example of possibilist/actualist difference, consider \(\exists x\Box P(x) \supset \Box \exists xP(x)\). With possibilist quantifiers, this is valid and reasonable. It asserts that if some possibilia has the \(P\) property in all alternative states, then in every alternative state some possibilia has the \(P\) property. But when possibilist quantification is replaced with actualist, \(\exists^{E}x\Box P(x) \supset \Box \exists^{E}xP(x)\), the result is no longer valid. As a blatant (but somewhat informal) example, say the actual state is \(\Gamma\) and \(P\) is the property of existing in state \(\Gamma\). Then, at \(\Gamma , \exists^{E}x\Box P(x)\) says something that actually exists has, in all alternative states, the property of existing in the state \(\Gamma\). This is true; in fact it is true of everything that exists in the state \(\Gamma\). But \(\Box \exists^{E}xP(x)\) says that in every alternative state there will be an actually existent object that also exists in the state \(\Gamma\), which need not be the case. In Section 3.2 a first order modal logic was sketched, in which quantification was over objects. Now a second kind of quantification is added, over intensions. As has been noted several times, an intensional object, or individual concept, will be modeled by a function from states to objects, but now we get into the question of what functions should be allowed. Intensions are supposed to be related to meanings. If we consider meaning to be a human construct, what constitutes an intension should probably be restricted. There should not, for instance, be more intensional objects than there are sentences that can specify meanings, and this limits intensions to a countable set. Or we might consider intensions as ‘being there,’ and we pick out the ones that we want to think about, in which case cardinality considerations don’t apply. This is an issue that probably cannot be settled once and for all. Instead, the semantics about to be presented allows for different choices in different models—it is not required that all functions from states to objects be present. It should be noted that, while this semantical gambit does have philosophical justification, it also makes an axiomatization possible. The fundamental point is the same as in the move from first to second order logic. If we insist that second order quantifiers range over all sets and relations, an axiomatization is not possible. If we use Henkin models, in which the range of second order quantifiers has more freedom, an axiomatization becomes available. Formulas are constructed more-or-less in the obvious way, with two kinds of quantified variables instead of one: extensional and intensional. But there is one really important addition to the syntactic machinery, and it requires some discussion. Suppose we have an intension, \(f\), that picks out an object in each state. For example, the states might be various ways the universe could have been constituted, and at each state \(f\) picks out the number of the planets which could, of course, be 0. Suppose \(P\) is a one-place relation symbol—what should be meant by \(P(f)\)? On the one hand, it could mean that the intension \(f\) has the property \(P\), on the other hand it could mean that the object designated by \(f\) has the property \(P\). Both versions are useful and correspond to things we say every day. We will allow for both, but the second version requires some cleaning up. Suppose \(P(f)\) is intended to mean that the object designated by \(f\) (at a state) has property \(P\). Then how do we read \(\Diamond P(f)\)? Under what circumstances should we take it to be true at state \(\Gamma\)? It could be understood as asserting the thing designated by \(f\) at \(\Gamma\) (call it \(f_{\Gamma })\) has the ‘possible-\(P\)’ property, and so at some alternative state \(\Delta\) we have that \(f_{\Gamma }\) has property \(P\). This is the de re reading, in which a possible property is ascribed to a thing. Another way of understanding \(\Diamond P(f)\) takes the possibility operator as primary: to say the formula is true at \(\Gamma\) means that at some alternative state, \(\Delta\), we have \(P(f)\), and so at \(\Delta\) the object designated by \(f\) (call it \(f_{\Delta })\) has property \(P\). This is the de dicto reading, possibility applies to a sentence. Of course there is no particular reason why \(f_{\Gamma }\) and \(f_{\Delta }\) should be identical. The de re and de dicto readings are different, both need representation, and we cannot manage this with the customary syntax. An abstraction mechanism will be used to disambiguate our syntax. The de re reading will be symbolized \([\lambda x\,\Diamond P(x)](f)\) and the de dicto will be symbolized \(\Diamond [\lambda x\,P(x)](f)\). The (incomplete) expression \([\lambda x\,X]\) is often called a predicate abstraction; one can think of it as the predicate abstracted from the formula \(X\). In \([\lambda x\,\Diamond P(x)](f)\) we are asserting that \(f\) has the possible-\(P\) property, while in \(\Diamond [\lambda x\,P(x)](f)\) we are asserting the possibility that \(f\) has the \(P\) property. Abstraction disambiguates. What we have said about \(\Diamond\) applies equally well to \(\Box\) of course. It should be noted that one could simply think of abstraction as a scope-specifying device, in a tradition that goes back to Russell, who made use of such a mechanism in his treatment of definite descriptions. Abstraction in modal logic goes back to Carnap 1947, but in a way that ignores the issues discussed above. The present usage comes from Stalnaker & Thomason 1968 and Thomason & Stalnaker 1968. Now the more technical part begins. There are two kinds of variables, object variables as before, and intension variables, or individual concept variables, \(f, g, g_{1}, g_{2},\ldots\). With two kinds of variables present, the formation of atomic formulas becomes a little more complex. From now on, instead of just being \(n\)-place for some \(n\), a relation symbol will have a type associated with it, where a type is an \(n\)-tuple whose entries are members of \(\{O, I\}\). An atomic formula is an expression of the form \(P(\alpha_{1}, \ldots ,\alpha_{n})\) where \(P\) is a relation symbol whose type is \(\langle t_{1}, \ldots ,t_{n}\rangle\) and, for each \(i\), if \(t_{i} = O\) then \(\alpha_{i}\) is an object variable, and if \(t_{i} = I\) then \(\alpha_{i}\) is an intension variable. Among the relation symbols we still have \(E\), which now is of type \(\langle O\rangle\), and we have \(=\), of type \(\langle O,O \rangle\). Formulas are built up from atomic formulas in the usual way, using propositional connectives, modal operators, and two kinds of quantifiers: over object variables and over intension variables. In addition to the usual formula-creating machinery, we have the following. If \(X\) is a formula, \(x\) is an object variable, and \(f\) is an intension variable, then \([\lambda x\,X](f)\) is a formula, in which the free variable occurrences are those of \(X\) except for \(x\), together with the displayed occurrence of \(f\). To distinguish the models described here from those in Section 3.2.2, these will be referred to as FOIL models, standing for first order intensional logic. They are discussed more fully in (Fitting 2004). A FOIL model is a structure  \(\cM =  \langle \bG, \bR, \bD_{O}, \bD_{i}, \bI\rangle\) where \(\langle \bG, \bR, \bD_{O}, \bI\rangle\) meets the conditions of Section 3.2.2, and in addition, \(\bD_{i}\) is a non-empty set of functions from \(\bG\) to \(\bD_{O}\); it is the intension domain. A first-order valuation in FOIL model   \(\cM\) is a mapping that assigns to each  object variable a member of \(\bD_{O}\), as before, and to each intension variable a member of \(\bD_{i}\). If \(f\) is an intension variable, we’ll write \(v(f, \Gamma )\) for \(v(f)(\Gamma )\). Now, the definition of truth, at a state \(\Gamma\) of a model  \(\cM\), with respect to a valuation  \(v\), meets the conditions set forth in Section 3.2.2 and, in addition, the following: Let us agree to abbreviate \([\lambda x\,[\lambda y\,X](g)](f)\) by \([\lambda xy\,X](f, g)\), when convenient. Suppose \(f\) is intended to be the intension of “the morning star,” and \(g\) is intended to be the intension of “the evening star.” Presumably \(f\) and \(g\) are distinct intensions. Even so, \([\lambda xy\,x = y]\)(f, g) is correct in the real world—both \(f\) and \(g\) do designate the same object. Here is another example that might help make the de re / de dicto distinction clearer. Suppose \(f\) is the intension of “the tallest person,” and \(g\) is the intension of “the oldest person,” and suppose it happens that, at the moment, these are the same people. Also, let us read \(\Box\) epistemically. It is unlikely we would say that \(\Box [\lambda xy\,x = y]\)(f, g) is the case. We can read \(\Box [\lambda xy\,x = y]\)(f, g) as saying we know that \(f\) and \(g\) are the same. It asserts that under all epistemic alternatives—all the various ways the world could be that are compatible with what we know—\(f\) and \(g\) designate the same object, and this most decidedly does not seem to be the case. However, we do have \([\lambda xy\,\Box (x = y)]\)(f, g), which we can read as saying we know of \(f\) and \(g\), that is, of their denotations, that they are the same, and this could be the case. It asserts that in all epistemic alternative states, what \(f\) and \(g\) designate in this one will be the same. In the setup described, \(f\) and \(g\) do designate the same object, and identity of objects carries over across states. It should be noted that the examples of designating terms just given are all definite descriptions. These pick out different objects in different possible worlds quite naturally. The situation with proper names and with mathematics is different, and will be discussed later in section 3.6. Here’s an example to show how the semantics works in a technical way. An intension is rigid if it is constant, the same in every state. We might think of a rigid intension as a disguised object, identifying it with its constant value. It should not be a surprise, then, that for rigid intensions, the distinction between de re and de dicto disappears. Indeed, something a bit stronger can be shown. Instead of rigidity, consider the weaker notion called local rigidity in Fitting and Mendelsohn 1998: an intension is locally rigid at a state if it has the same designation at that state that it has at all accessible ones. To say \(f\) is locally rigid at a state, then, amounts to asserting the truth of \([\lambda x\,\Box [\lambda y\,x = y](f)](f)\) at that state. Local rigidity at a state implies the de re /de dicto distinction vanishes at that state. To show how the formal semantics works, here is a verification of the validity of In a similar way one can establish the validity of and from these two follows the validity of which directly says local rigidity implies the de re /de dicto distinction vanishes. Suppose \eqref{eq2} were not valid. Then there would be a model  \(\cM = \langle \bG, \bR, \bD_{O}, \bD_{i}, \bI\rangle\), a state \(\Gamma\) of it, and a valuation \(v\) in it, such that From \eqref{eq6} we have the following, where \(w\) is the \(x\)-variant of \(v\) such that \(w(x) = v (f, \Gamma )\). By \eqref{eq8} there is some \(\Delta \in \bG\) with \(\Gamma \bR \Delta\) such that we have the following. Then, as a consequence of \eqref{eq7} and hence we have the following, where \(w'\) is the \(x\)-variant of \(v\) such that \(w'(x) = v(f, \Delta )\). Now from \eqref{eq5}, since \(w(x) = v(f, \Gamma)\), we have and so and hence where \(w''\) is the \(y\)-variant of \(w\) such that \(w''(y) = w(f, \Delta )\). We claim that valuations \(w\) and \(w'\) are the same, which means that \eqref{eq9} and \eqref{eq11} are contradictory. Since both are \(x\)-variants of \(v\), it is enough to show that \(w(x) = w'(x)\), that is, \(v(f, \Gamma ) = v(f, \Delta )\), which is intuitively what local rigidity says. Proceeding formally, \(v(f, \Gamma ) = w(x) = w''(x)\) since \(w''\) is a \(y\)-variant of \(w\) and so they agree on \(x\). We also have \(v(f, \Delta ) = w''(y)\). And finally, \(w''(x) = w''(y)\) by \eqref{eq14}. Having reached a contradiction, we conclude that \eqref{eq2} must be valid. In models the domain of intensions is to be some non-empty set of functions from states to objects. We have deliberately left vague the question of which ones we must have. There are some conditions we might want to require. Here are some considerations along these lines, beginning with a handy abbreviation. (where \(x\) and \(y\) are distinct object variables). Working through the FOIL semantics,   \(\cM, \Gamma \vDash_{v} D(f,x)\) is true just in case \(v(f, \Gamma ) = v(x)\). Thus \(D(f, x)\) says the intension \(f\) designates the object \(x\). The formula \(\forall f\exists xD(f, x)\) is valid in FOIL models as described so far. It simply says intensions always designate. On the other hand, there is no a priori reason to believe that every object is designated by some intension, but under special circumstances we might want to require this. We can do it by restricting ourselves to models in which we have the validity of If we require \eqref{eq16}, quantification over objects is reducible to intensional quantification: More precisely, the implication \(\eqref{eq16} \supset \eqref{eq17}\) is valid in FOIL semantics. We also might want to require the existence of choice functions. Suppose that we have somehow associated an object \(d_{\Gamma }\) with each state \(\Gamma\) of a model. If our way of choosing \(d_{\Gamma }\) can be specified by a formula of the language, we might want to say we have specified an intension. Requiring the validity of the following formula seems as close as we can come to imposing such an existence condition on FOIL models. For each formula \(\Phi\): “The King of France in 1700” denotes an object, Louis XIV, who does not exist, but did. “The present King of France” does not denote at all. To handle such things, the representation of an intension can be generalized from being a total function from states to objects, to being a partial function. We routinely talk about non-existent objects—we have no problem talking about the King of France in 1700. But there is nothing to be said about the present King of France—there is no such thing. This will be our guide for truth conditions in our semantics. The language stays the same, but intension variables are now interpreted by partial functions on the set of states—functions whose domains may be proper subsets of the set of states. Thus   \(\cM = \langle \bG, \bR, \bD_{O}, \bD_{i}, \bI\rangle\) is a partial FOIL model if it is as in Section 3.4 except that members of \(\bD_{i}\) are partial functions from \(\bG\) to \(\bD_{O}\). Given a partial FOIL model  \(\cM\)  and a valuation \(v\) in it, an intension variable \(f\) designates at state \(\Gamma\) of this model with respect to \(v\) if \(\Gamma\) is in the domain of \(v(f)\). Following the idea that nothing can be said about the present King of France, we break condition \eqref{cond1} from Section 3.4 into two parts. Given a partial FOIL model  \(\cM\)  and a valuation \(v\) in it: Thus designating terms behave as they did before, but nothing can be truly asserted about non-designating terms. Recall, we introduced a formula \eqref{eq15} abbreviated by \(D(f,x)\) to say \(f\) designates \(x\). Using that, we introduce a further abbreviation. This says \(f\) designates. Incidentally, we could have used \([\lambda x\,x = x](f)\) just as well, thus avoiding quantification. It is important to differentiate between existence and designation. As things have been set up here, existence is a property of objects, but designation really applies to terms of the formal language, in a context. To use a temporal example from Fitting and Mendelsohn 1998, in the usual sense “George Washington” designates a person who does not exist, though he once did, while “George Washington’s eldest son,” does not designate at all. That an intensional variable \(f\) designates an existent object is expressed by an abstract, \([\lambda x\,E(x)](f)\). We have to be a bit careful about non-existence though. That \(f\) designates a non-existent is not simply the denial of the previous expression, \(\neg [\lambda x\,E(x)](f)\). After all, \([\lambda x\,E(x)](f)\) expresses that \(f\) designates an existent, so its denial says either \(f\) does not designate, or it does, but designates a non-existent. To express that \(f\) designates, but designates a non-existent, we need \([\lambda x\,\neg E(x)](f)\). The formula \(\forall f([\lambda x\,E(x)](f)  \vee \neg [\lambda\)x E\((x)](f))\) is valid, but  \(\forall f([\lambda x\,E(x)](f)  \vee   [\lambda x\,\neg E(x)](f))\) is not—one can easily construct partial FOIL models that invalidate it. What we do have is the following important item. In words, intensional terms that designate must designate existents or non-existents. In earlier parts of this article, among the examples of intensions and partial intensions have been “the present King of France,” “the tallest person,” and “the oldest person.” One could add to these “the number of people,” and “the positive solution of \(x^{2} - 9 = 0\).” All have been specified using definite descriptions. In a temporal model, the first three determine partial intensions (there have been instants of time with no people); the fourth determines an intension that is not partial; the fifth determines an intension that is rigid. So far we have been speaking informally, but there are two equivalent ways of developing definite descriptions ideas formally. The approach introduced by Bertrand Russell (Russell 1905, Whitehead and Russell 1925) is widely familiar and probably needs little explication here. Suffice it to say, it extends to the intensional setting without difficulty. In this approach, a term-like expression, \(\atoi y\phi (y)\),  is introduced, where \(\phi (y)\) is a formula and \(y\) is an object variable. It is read, “the \(y\) such that \(\phi (y)\).” This expression is given no independent meaning, but there is a device to translate it away in an appropriate context. Thus,  \([\lambda x\,\psi (x)] \atoi y\phi (y))\)  is taken to abbreviate the formula \(\exists y[\forall z(\phi (z) \equiv z = y)  \wedge \psi (y)]\).   (The standard device has been used of writing \(\phi (z)\) to represent the substitution instance of \(\phi (y)\) resulting from replacing free occurrences of \(y\) with occurrences of \(z\), and modifying bound variables if necessary to avoid incidental capture of \(z\).) The present abstraction notation, using \(\lambda\), is not that of Russell, but he used an equivalent scoping device. As he famously pointed out, Russell’s method allows us to distinguish between “The present King of France is not bald,” which is false because there is no present King of France, and “It is not the case that the present King of France is bald,” which is true because “The present King of France is bald” is false. It becomes the distinction between  \([\lambda x\,\neg\textit{Bald}(x)](\atoi y\textit{King}(y))\)  and  \(\neg [\lambda x\textit{Bald}(x)](\atoi y\textit{King}(y))\). As an attractive alternative, one could make definite descriptions into first-class things. Enlarge the language so that if \(\phi (y)\) is a formula where \(y\) is an object variable, then  \(\atoi y\phi (y)\)  is an intension term whose free variables are those of \(\phi (y)\) except for \(y\). Then modify the definition of formula, to allow these new intension terms to appear in places we previously allowed intension variables to appear. That leads to a complication, since intension terms involve formulas, and formulas can contain intension terms. In fact, formula and term must be defined simultaneously, but this is no real problem. Semantically we can model definite descriptions by partial intensions. We say the term  \(\atoi y\phi (y)\)  designates at state \(\Gamma\) of a partial FOIL model  \(\cM\) with respect to valuation  \(v\) if   \(\cM, \Gamma \vDash_{w} \phi (y)\) for exactly one \(y\)-variant \(w\) of \(v\). Then the conditions from section 3.5.1 are extended as follows. One can show that the Russell approach and the approach just sketched amount to more-or-less the same thing. But with definite descriptions available as formal parts of the language, instead of just as removable abbreviations in context, one can see they determine intensions (possibly partial) that are specified by formulas. A property need not hold of the corresponding definite description, that is,  \([\lambda x\,\phi (x)](\atoi x\phi (x))\)  need not be valid. This is simply because the definite description might not designate. However, if it does designate, it must have its defining property. Indeed, we have the validity of the following: One must be careful about the interaction between definite descriptions and modal operators, just as between them and negation. For instance,  \(D(\atoi x\Diamond \phi (x)) \supset \Diamond D(\atoi x\phi (x))\)  is valid, but its converse is not. For a more concrete example of modal/description interaction, suppose \(K(x)\) is a formula expressing that \(x\) is King of France. In the present state,  \([\lambda x\,\Diamond E(x)](\atoi xK(x))\)  is false, because the definite description has no designation, but  \(\Diamond [\lambda x\,E(x)](\atoi xK(x))\) is true, because there is an alternative (earlier) state in which the definite description designates an existent object. It was noted that for rigid terms the de re/de dicto distinction collapses. Indeed, if \(f\) and \(g\) are rigid, \([\lambda xy\ x=y](f, g)\), \({\square}[\lambda xy\ x=y](f, g)\) and \([\lambda xy\ {\square}x=y](f, g)\) are all equivalent. This is a problem that sets a limit on what can be handled by the Carnap-style logic as presented so far. Two well-known areas of difficulty are mathematics and proper names, especially in an epistemic setting. How could someone not know that \(1 + 4 = 2 + 3\)? Yet it happens for small children, and for us bigger children similar, but more complex, examples of mathematical truths we don’t know can be found. Obviously the designations of “\(1 + 4\)” and “\(2 + 3\)” are the same, so their senses must be different. But if we model sense by a function from states to designations, the functions would be the same, mapping each state to 5. If it is necessary truth that is at issue, there is no problem; we certainly want that \(1 + 4 = 2 + 3\) is a necessary truth. But if epistemic issues are under consideration, since we cannot have a possible world in which “\(1 + 4\)” and “\(2 + 3\)” designate different things, “\(1 + 4 = 2 + 3\)” must be a known truth. So again, how could one not know this, or any other mathematical truth? One possible solution is to say that for mathematical terms, intension is a different thing than it is for definite descriptions like “the King of France.” The expression “\(1 + 4\)” is a kind of miniature computing program. Exactly what program depends on how we were taught to add, but let us standardize on: \(x + y\) instructs us to start at the number \(x\) and count off the next \(y\) numbers. Then obviously, “\(1 + 4\)” and “\(2 + 3\)” correspond to different programs with the same output. We might identify the program with the sense, and the output with the denotation. Then we might account for not knowing that \(1 + 4 = 2 + 3\) by saying we have not executed the two programs, and so can’t conclude anything about the output. Identifying the intension of a mathematical term with its computational content is a plausible thing to do. It does, however, clash with what came earlier in this article. Expressions like “the King of France” get treated one way, expressions like “\(1 + 4\)” another. For any given expression, how do we decide which way to treat it? It is possible to unify all this. Here is one somewhat simple-minded way. If we think of the sense of “\(1 + 4\)” as a small program, there are certainly states, possible worlds, in which we have not executed the program, and others in which we have. We might, then, think of the intension of “\(1 + 4\)” as a partial function on states, whose domain is the set of states in which the instructions inherent in “\(1 + 4\)” have been executed, and mapping those states to 5. Then, clearly, we can have states of an epistemic possible world model in which we do not know that “\(1 + 4\)” and “\(2 + 3\)” have the same outputs. This can be pushed only so far. We might be convinced by some general argument that addition is a total function always defined. Then it is conceivable that we might know “\(1 + 4\)” designates some number, but not know what it is. But this cannot be captured using the semantics outlined thus far, assuming arithmetic terms behave correctly. If at some state we know \(\exists x([\lambda y\ x = y](1 + 4))\), that is, we know “\(1 + 4\)” designates, then at all compatible states, “\(1 + 4\)” designates, and since arithmetic terms behave correctly, at all compatible states “\(1 + 4\)” must designate 5, and hence we must know \([\lambda y\ 5 = y](1 + 4)\) at the original state. We cannot know “\(1 + 4\)” designates without knowing what. It is also possible to address the problem from quite a different direction. One does not question the necessity of mathematical truths—the issue is an epistemic one. And for this, it has long been noted that a Hintikka-style treatment of knowledge does not deal with actual knowledge, but with potential knowledge—not what we know, but what we are entitled to know. Then familiar logical omniscience problems arise, and we have just seen yet another instance of them. A way out of this was introduced in Fagin and Halpern 1988, called awareness logic. The idea was to enrich Hintikka’s epistemic models with an awareness function, mapping each state to the set of formulas we are aware of at that state. The idea was that an awareness function reflects some bound on the resources we can bring to bear. With such semantical machinery, we might know simple mathematical truths but not more complex ones, simply because they are too complex for us. Awareness, in this technical sense, is a blunt instrument. A refinement was suggested in van Benthem 1991: use explicit knowledge terms. As part of a project to provide a constructive semantics for intuitionistic logic, a formal logic of explicit proof terms was presented in Artemov 2001. Later a possible world semantics for it was created in Fitting 2005. In this logic truths are known for explicit reasons, and these explicit reasons provide a measure of complexity. The work was subsequently extended to a more general family of justification logics, which are logics of knowledge in which reasons are made explicit. In justification logics, instead of the familiar \(KX\) of epistemic logic we have \(t{:}X\), where \(t\) is an explicit justification term. The formula \(t{:}X\) is read, “\(X\) is known for reason \(t\).” Justification terms have structure which varies depending on the particular justification logic being investigated. Common to all justification logics is the following minimal machinery. First there are justification constants, intended to be unanalyzed justifications of accepted logical truths. Second, there are justification variables, standing for arbitrary justifications. And finally there are binary operations, minimally \(\cdot\) and \(+\). The intention is that if \(s\) justifies \(X \supset Y\) and \(t\) justifies \(X\), then \(s\cdot t\) justifies \(Y\), and also \(s+t\) justifies anything that \(s\) justifies and also anything that \(t\) justifies. There are very close connections between justification logics and epistemic logics, embodied in Realization Theorems. This is not the appropriate place to go into details; a thorough discussion of justification logics can be found in this encyclopedia's entry on justification logic. If one follows the justification logic approach one might say, of \(1 + 4 = 2 + 3\) or some more complicated mathematical truth, that it is knowable but too hard for us to actually know. That is, the justification terms embodying our reasons for this knowledge are too complex for us. This follows the general idea of awareness logic, but with a specific and mathematically useful measure of the complexity of our awareness. Proper names are even more of a problem than mathematical expressions. These days proper names are generally understood to be rigid designators but, unlike mathematical terms, they have no structure that we can make use of. Here is a very standard example. Suppose “Hesperus” is used as a name for the evening star, and “Phosphorus” for the morning star. It should be understood that “the evening star” is conventional shorthand for a definite description, “the first heavenly body seen after sunset” and similarly for “the morning star”. Definite descriptions have structure, they pick out objects and in different possible worlds they may pick out different objects. But proper names are not like that. Once the designations of “Hesperus” and “Phosphorus” are fixed—as it happens they both name the planet Venus—that designation is fixed across possible worlds and so they are rigid designators. It follows that while the morning star is the evening star, that identity is not necessary because definite descriptions are not rigid, but Hesperus is Phosphorus and that identity is a necessary one. How, then, could the identity of Hesperus and Phosphorus not be a known truth, known without doing any astronomical research? There is more than one solution of the dilemma just mentioned. One way is very simple indeed. Possible world models can be used to represent various kinds of modalities. They provide mathematical machinery, but they do not say what the machinery is for. That is up to the user. So, we might want to have such a model to represent necessary truth, or we might want to have such a model to represent epistemic issues. The argument that proper names are rigid designators applies to models representing necessary truth. It does not follow that this is the case for epistemic models too. Here is a quote from (Kripke 1980) that sheds some light on the issue. But being put in a situation where we have exactly the same evidence, qualitatively speaking, it could have turned out that Hesperus was not Phosphorus; that is, in a counterfactual world in which ‘Hesperus’ and ‘Phosphorus’ were not used in the way that we use them, as names of this planet, but as names of some other objects, one could have had qualitatively identical evidence and concluded that ‘Hesperus’ and ‘Phosphorus’ named two different objects. But we, using the names as we do right now, can say in advance, that if Hesperus and Phosphorus are one and the same, then in no other possible world can they be different. We use ‘Hesperus’ as the name of a certain body and ‘Phosphorus’ as the name of a certain body. We use them as names of these bodies in all possible worlds. If, in fact, they are the same body, then in any other possible world we have to use them as a name of that object. And so in any other possible world it will be true that Hesperus is Phosphorus. So two things are true: first, that we do not know a priori that Hesperus is Phosphorus, and are in no position to find out the answer except empirically. Second, this is so because we could have evidence qualitatively indistinguishable from the evidence we have and determine the reference of the two names by the positions of two planets in the sky, without the planets being the same. In short, proper names are rigid designators in models where the possible worlds represent logically alternative states. They need not be rigid designators in models where the possible worlds represent epistemically alternative states. Hesperus and Phosphorus are the same, necessarily so, but we could have used the names “Hesperus” and “Phosphorus” differently without being able to tell we were doing so—a state in which we did this might be epistemically indistinguishable from the actual one. There can be necessary identities that we do not know because necessary truth and known truth do not follow the same rules. The formal machinery behind the discussion above traces back to ideas of Carnap. In this tradition possible worlds are central, and sense or intension is a function from possible worlds to denotations. Senses determine denotations, but detailed machinery accounting for how this happens is not made concrete (except for definite descriptions). One need not do things this way. If the Church approach is followed, one can simply say that “Hesperus” and “Phosphorus” have the same designation rigidly, hence necessarily, but even so they do not have the same sense. This is possible because senses are, in effect, independent and not derived things. Senses can determine the same extension across possible worlds without being identical. A logic breaking the Carnapian mold, that is thorough and fully developed, can be found in Zalta 1988. In this a class of abstract objects is postulated, some among them being ordinary. A distinction is made between an object exemplifying a property and encoding it. For instance, an abstract object might perfectly well encode the property of being a round square, but could not exemplify it. A general comprehension principle is assumed, in the form that conditions determine abstract individuals that encode (not exemplify) the condition. Identity is taken to hold between objects if they are both abstract and encode the same properties, or they are both ordinary and exemplify the same properties. In effect, this deals with problems of substitutivity. The formal theory (more properly, theories) is quite general and includes both logical necessity and temporal operators. It is assumed that encoding is not contingent, though exemplifying may be, and thus properties have both an exemplification extension that can vary across worlds, and an encoding extension that is rigid. With all this machinery available, a detailed treatment of proper names can be developed, along with much else.