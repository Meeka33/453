 Bisimulation provides a good example of the fruitful interactions that have been developed between modal logic and computer science. In computer science, labeled transition systems (LTSs) are commonly used to represent possible computation pathways during execution of a program. LTSs are generalizations of Kripke frames, consisting of a set \(W\) of states, and a collection of \(i\)-accessibility relations \(R_i\), one for each computer process \(i\). Intuitively, \(wR_i w'\) holds exactly when \(w'\) is a state that results from applying the process \(i\) to state \(w\). The language of poly-modal or dynamic logic introduces a collection of modal operators \(\Box_i\), one for each program \(i\) (Harel, 1984). Then \(\Box_i\)A states that sentence \(A\) holds in every result of applying \(i\). So ideas like the correctness and successful termination of programs can be expressed in this language. Models for such a language are like Kripke models save that LTSs are used in place of frames. A bisimulation is a counterpart relation between states of two such models such that exactly the same propositional variables are true in counterpart states, and whenever world \(v\) is \(i\)-accessible from one of two counterpart states, then the other counterpart bears the \(i\)-accessibility relation to some counterpart of \(v\). In short, the \(i\)-accessibility structure one can “see” from a given state mimics what one sees from a counterpart. Bisimulation is a weaker notion than isomorphism (a bisimulation relation need not be 1-1), but it is sufficient to guarantee equivalence in processing. In the 1970s, a version of bisimulation had already been developed by modal logicians to help better understand the relationship between modal logic axioms and their corresponding conditions on Kripke frames. Kripke’s semantics provides a basis for translating modal axioms into sentences of a second-order language where quantification is allowed over one-place predicate letters \(P\). Replace metavariables \(A\) with open sentences \(Px\), translate \(\Box Px\) to \(\forall y(Rxy \rightarrow Py)\), and close free variables \(x\) and predicate letters \(P\) with universal quantifiers. For example, the predicate logic translation of the axiom schema \(\Box A\rightarrow A\) comes to \(\forall P \forall x[\forall y(Rxy\rightarrow Py) \rightarrow Px\)]. Given this translation, one may instantiate the variable \(P\) to an arbitrary one-place predicate, for example to the predicate \(Rx\) whose extension is the set of all worlds w such that \(Rxw\) for a given value of \(x\). Then one obtains \(\forall x[\forall y(Rxy\rightarrow Rxy) \rightarrow Rxx\)], which reduces to \(\forall xRxx\), since \(\forall y(Rxy\rightarrow Rxy)\) is a tautology. This illuminates the correspondence between \(\Box A\rightarrow A\) and reflexivity of frames \((\forall xRxx)\). Similar results hold for many other axioms and frame conditions. The “collapse” of second-order axiom conditions to first order frame conditions is very helpful in obtaining completeness results for modal logics. For example, this is the core idea behind the elegant results of Sahlqvist (1975). But when does the second-order translation of an axiom reduce to a first-order condition on \(R\) in this way? In the 1970s, van Benthem showed that this happens iff the translation’s holding in a model entails its holding in any bisimular model, where two models are bisimular iff there is a bisimulation between them in the special case where there is a single accessibility relation. That result generalizes easily to the poly-modal case (Blackburn et. al., 2001, p. 103).  This suggests that poly-modal logic lies at exactly the right level of abstraction to describe, and reason about, computation and other processes. (After all, what really matters there is the preservation of truth values of formulas in models rather than the finer details of the frame structures.) Furthermore the implicit translation of those logics into well-understood fragments of predicate logic provides a wealth of information of interest to computer scientists. As a result, a fruitful area of research in computer science has developed with bisimulation as its core idea (Ponse et al. 1995).