 In order to define the semantics of second-order logic we have to agree what our metalanguage is. This fact has nothing to do with second-order logic but is rather a general feature of semantics (Tarski 1933 [1956]). The most commonly used metalanguage for second-order logic is set theory. We thus give a set-theoretical interpretation of second-order logic, interpreting “properties” as sets. This is the most common choice and brings out the main features of second-order logic. We cannot interpret all properties by sets, e.g. the property of being identical to oneself. But if the domain that the individual variables range over is taken to be a set, then we can meaningfully interpret properties of individuals in that domain as sets. If we want to interpret second-order logic in a domain which is too large to be a set, we can use the set-theoretical concept of a class (see entry on  set theory  for more on classes). We use the same concept of an L-structure (or equivalently, an L-model) as in first order logic. That is, an L-structure \(\mm\) has a domain M, which is any non-empty set, an interpretation \(c^\mm \in M\) of any constant symbol c of L, an interpretation \(R^\mm \subseteq M^n\) of any n-ary relation symbol R of L, as well as an interpretation \(H^\mm : M^n \to M\) of any n-ary function symbol H of L. Convention: Whenever we use upper case Fraktur letters, such as \(\mm,\mn\) etc, to name a structure, we use the upper case Italic versions of those letters, such as \(M,N\) etc, to name the domain of the structure. Given an L-structure \(\mm\), an assignment is a function s from variables to the domain M of \(\mm\) such that: if x is an individual variable, then \(s(x) \in M\); if X is relation variable of arity n, then \(s(X) \subseteq M^n\); if F is function variable of arity n, then \(s(F) : M^n \to M\). We use \(s(P/X)\) to denote the assignment which is otherwise as s except that the value at X has been changed to P. Similarly \(s(a/x)\) and \(s(f/F)\). The value \(t^\mm\langle s\rangle\) of a term t in a model \(\mm\) under the interpretation s is defined as in first order logic. The concept \(\mm\models\phi\) of the truth of the sentence \(\phi\) in \(\mm\) can now be defined by first defining the auxiliary concept \(\mm\models_s\phi\) of the assignment \(s\) satisfying \(\phi\) in \(\mm\) (see entry on  Tarski's truth definitions  for more details): Definition 2 (Tarski’s Truth Definition) The truth definition for second-order logic extends the respective truth definition for first order logic by the clauses: and similarly for the universal quantifiers. For a sentence \(\phi\) we define \(\mm\models\phi\) to mean \(\mm\models_s\phi\) for all (equivalently some) s, and then say \(\phi\) is true in \(\mm\). In clause 1 of the above definition we follow the common practice of giving a set-theoretical interpretation to the predication \(X(t_1,\ldots,t_n)\). Having interpreted X as a subset of \(M^n\), we interpret predication \(X(t_1,\ldots,t_n)\) as membership \((t^\mm_1 \langle s\rangle,\ldots,t^\mm_n \langle s\rangle) \in s(X)\). In clause 2 we interpret quantification over properties and relations as quantification over subsets of the cartesian product \(M^n\). Respectively, in clause 3 we interpret quantification over functions as quantification over sets that are functions \(M^n\to M\) in the set-theoretical sense. Now that the semantics of second-order logic is defined we can define what it means for a formula \(\phi\) to be valid and for two formulas \(\phi\) and \(\psi\) to be logically equivalent. As in logic in general, we say that \(\phi\) is (logically) valid if \(\mm\models_s\phi\) holds for all \(\mm\) and all s. Likewise, we define \(\phi\) and \(\psi\) to be logically equivalent, \(\phi\equiv\psi\), if \(\phi\leftrightarrow\psi\) is valid. Two models \(\mm\) and \(\mn\) are said to be second-order equivalent, in symbols \(\mm\equiv_{L^2}\mn\) if for all sentences \(\phi\) we have \(\mm\models\phi\iff\mn\models\psi\). The truth definition involves the concepts “for some \(P \subseteq M^n\)” and “for some \(f:M^n \to M\)”. Since we assume set theory as our metalanguage, we can interpret these in the sense of set theory. Thus we interpret “for some \(P \subseteq M^n\)” as “for some set \(P \subseteq M^n\)” and “for some \(f:M^n\to M\)” as “for some set which is a function \(f:M^n\to M\)”. For infinite M the collection of subsets of \(M^n\) and the set of functions \(M^n\to M\) are famously complex. Currently set theory (ZFC) cannot even decide how many subsets of an infinite set there are. The situation is quite different with first order logic. The respective concept “for some \(a \in M\)” is unproblematic, relatively speaking. Of course, depending on what M is, “for some \(a \in M\)” can be quite problematic too. To reflect the difficulties involved with finding a \(P \subseteq M^n\) or an \(f:M^n \to M\) we sometimes say we “guess” a \(P \subseteq M^n\) or an \(f:M^n \to M\). When we use set theory as the metatheory for the semantics of first order logic, the reliance on the metatheory is of a lower degree than when we use set theory as the metatheory for the semantics of second order logic. The central concept, which explains the difference, is that of absoluteness. For details, see  §6. The Ehrenfeucht-Fraïssé game is a game-theoretic tool for investigating to what extent two models are similar (see entry on  logic and games  for a general introduction to Ehrenfeucht-Fraïssé games). Two isomorphic models would be very similar but normally we are interested in similarity of models that are not isomorphic. The Ehrenfeucht-Fraïssé game of second-order logic characterizes \(\ma\equiv_{L^2}\mn\), i.e. the proposition that exactly the same second-order sentences are true in \(\ma\) and \(\mb\), just as the Ehrenfeucht-Fraïssé game of first order logic characterizes the first order elementary equivalence \(\ma\equiv\mn\). See the entry on  first-order model theory  for more on elementary equivalence. For simplicity we disallow function and constant symbols as well as function variables in this section. Suppose \(\ma\) and \(\mb\) are two models of the same finite relational vocabulary. In the game which we denote by \(G^2_n(\ma,\mb)\) two players I and II pick one at a time subsets (or elements) of A or subsets (or elements) of B. During round i of the game player I can pick a relation \(A_i\) on A (or an element \(a_i\) of A) and then player II has to pick a relation \(B_i\) on B of the same arity as \(A_i\) (or an element \(b_i\) of on B) and vice versa: Player I can instead pick a relation \(B_i\) on B (or an element \(b_i\) of B) and then II picks a relation \(A_i\) on A of the same arity as \(B_i\) (or an element \(a_i\)) of A. After n rounds the pairs of played elements \((a_i,b_i)\) form a binary relation R on \(A\times B\). If this relation is a partial isomorphism of the structures \(\ma\) and \(\mb\) expanded by the played relations \(A_i\) and \(B_i\), i.e., it preserves atomic formulas and their negations, we say that II has won. The models \(\ma\) and \(\mb\) satisfy the same second-order sentences if and only if for each \(n\in \oN\) Player II has a winning strategy in \(G^2_n(\ma,\mb)\). A model class (i.e. a class of models of a fixed vocabulary, closed under isomorphisms) K is definable in second-order logic if and only if there is an n such that if \(\ma\in K\) and Player II has a winning strategy in the \(G^2_n(\ma,\mb)\), then \(\mb\in K\). The first order version \(G^1_n(\ma,\mb)\), where players play only individual elements, i.e., no relations are played, is very useful in working with first order logic. Unfortunately the game \(G^2_n(\ma,\mb)\) is much more complex. It is very difficult to invent winning strategies for Player II except in the trivial case when \(\ma\cong\mb\). If Player I plays a binary relation R on A, Player II should be able to play a binary relation \(R'\) on B such that whatever challenges Player I makes in the rest of the game, even involving new binary relations, the relations R and \(R'\) look similar. If \(V=L\), then countable second-order equivalent models (with a finite vocabulary) are actually isomorphic (Ajtai 1979). For details, see  §10.  Thus consistently in countable models there is no other winning strategy for Player II than an isomorphism. Perhaps this explains why the game is not as useful in second-order logic as it is in first order logic. However, if we restrict to monadic second-order logic, which in terms of the Ehrenfeucht-Fraïssé game means restricting the game to unary predicates, the situation changes. A unary predicate just divides the model into two parts. If Player I divides A into two parts, Player II should find a similar division in B. This is more reasonable and there actually are useful strategies for Player II. For examples in the finite context see  §16.