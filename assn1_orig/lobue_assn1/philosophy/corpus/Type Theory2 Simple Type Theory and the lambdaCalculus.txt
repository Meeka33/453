 As we saw above, the distinction: objects, predicates, predicate of predicates, etc., seems enough to block Russell’s paradox (and this was recognised by Chwistek and Ramsey). We first describe the type structure as it is in Principia and later in this section we present the elegant formulation due to Church 1940 based on \(\lambda\)-calculus. The types can be defined as For instance, the type of binary relations over individuals is \((i, i)\), the type of binary connectives is \(((\,),(\,))\), the type of quantifiers over individuals is \(((i))\). For forming propositions we use this type structure: thus \(R(a_1 ,\ldots ,a_n)\) is a proposition if \(R\) is of type \((A_1 ,\ldots ,A_n)\) and \(a_i\) is of type \(A_i\) for \(i = 1,\ldots ,n\). This restriction makes it impossible to form a proposition of the form \(P(P)\): the type of \(P\) should be of the form \((A)\), and \(P\) can only be applied to arguments of type \(A\), and thus cannot be applied to itself since \(A\) is not the same as \((A)\). However simple type theory is not predicative: we can define an object \(Q(x, y)\) of type \((i, i)\) by Assume that we have two individuals \(a\) and \(b\) such that \(Q(a, b)\) holds. We can define \(P(x)\) to be \(Q(x, a)\). It is then clear that \(P(a)\) holds, since it is \(Q(a, a)\). Hence \(P(b)\) holds as well. We have proved, in an impredicative way, that \(Q(a, b)\) implies \(Q(b, a)\). Alternative simpler formulations, which retain only the notion of classes, classes of classes, etc., were formulated by Gödel and Tarski. Actually this simpler version was used by Gödel in his 1931 paper on formally undecidable propositions. The discovery of the undecidable propositions may have been motivated by a heuristic argument that it is unlikely that one can extend the completeness theorem of first-order logic to type theory (see the end of his Lecture at Königsberg 1930 in Gödel Collected Work,  Volume III and Goldfarb 2005).  Tarski had a version of the definability theorem expressed in type theory (see Hodges 2008). See Schiemer and Reck 2013. We have objects of type 0, for individuals, objects of type 1, for classes of individuals, objects of type 2, for classes of classes of individuals, and so on. Functions of two or more arguments, like relations, need not be included among primitive objects since one can define relations to be classes of ordered pairs, and ordered pairs to be classes of classes. For example, the ordered pair of individuals a, b can be defined to be \(\{\{a\},\{a,b\}\}\) where \(\{x,y\}\) denotes the class whose sole elements are \(x\) and \(y\). (Wiener 1914 had suggested a similar reduction of relations to classes.) In this system, all propositions have the form \(a(b)\), where \(a\) is a sign of type \(n+1\) and \(b\) a sign of type \(n\). Thus this system is built on the concept of an arbitrary class or subset of objects of a given domain and on the fact that the collection of all subsets of the given domain can form a new domain of the next type. Starting from a given domain of individuals, this process is then iterated. As emphasised for instance in Scott 1993, in set theory this process of forming subsets is iterated into the transfinite. In these versions of type theory, as in set theory, functions are not primitive objects, but are represented as functional relation. The addition function for instance is represented as a ternary relation by an object of type \((i,i,i)\). An elegant formulation of the simple type theory which extends it by introducing functions as primitive objects was given by Church in 1940. It uses the \(\lambda\)-calculus notation (Barendregt 1997). Since such a formulation is important in computer science, for the connection with category theory, and for Martin-Löf type theory, we describe it in some detail. In this formulation, predicates are seen as a special kind of functions (propositional functions), an idea that goes back to Frege (see for instance Quine 1940). Furthermore, the notion of function is seen as more primitive than the notion of predicates and relations, and a function is not defined anymore as a special kind of relation. (Oppenheimer and Zalta 2011 presents some arguments against such a primitive representation of functions.) The types of this system are defined inductively as follows We can form in this way the types: which correspond to the types \((i)\) and \(((i))\) but also the new types It is convenient to write for In this way corresponds to the type \((A_1 ,\ldots ,A_n)\). First-order logic considers only types of the form Notice that stands for (association to the right). For the terms of this logic, we shall not follow Church’s account but a slight variation of it, due to Curry (who had similar ideas before Church’s paper appeared) and which is presented in detail in R. Hindley’s book on type theory. Like Church, we use \(\lambda\)-calculus, which provides a general notation for functions Here we have used the so-called BNF notation, very convenient in computing science. This gives a syntactic specification of the \(\lambda\)-terms which, when expanded, means: The notation for function application \(M N\) is a little different than the mathematical notation, which would be \(M(N)\). In general, stands for (association to the left). The term \(\lambda x.M\) represents the function which to \(N\) associates \(M[x:=N\)]. This notation is so convenient that one wonders why it is not widely used in mathematics. The main equation of \(\lambda\)-calculus is then \((\beta\)-conversion) which expresses the meaning of \(\lambda x.M\) as a function. We have used \(M[x:=N\)] as a notation for the value of the expression that results when \(N\) is substituted for the variable \(x\) in the matrix \(M\). One usually sees this equation as a rewrite rule \((\beta\)-reduction) In untyped lambda calculus, it may be that such rewriting does not terminate. The canonical example is given by the term \(\Delta = \lambda x.x x\) and the application (Notice the similarity with Russell’s paradox.) The idea of Curry is then to look at types as predicates over lambda terms, writing \(M:A\) to express that \(M\) satisfies the predicate/type \(A\). The meaning of is then which justifies the following rules In general one works with judgements of the form where \(x_1,..., x_n\) are distinct variables, and \(M\) is a term having all free variables among \(x_1,..., x_n\). In order to be able to get Church’s system, one adds some constants in order to form propositions. Typically The term represents the predicate of predicates that do not apply to themselves. This term does not have a type however, that is, it is not possible to find \(A\) such that which is the formal expression of the fact that Russell’s paradox cannot be expressed. Leibniz equality will be defined as One usually writes \(\forall x[M\)] instead of \(\forall(\lambda x.M)\), and the definition of \(Q\) can then be rewritten as This example again illustrates that we can formulate impredicative definitions in simple type theory. The use of \(\lambda\)-terms and \(\beta\)-reduction is most convenient for representing the complex substitution rules that are needed in simple type theory. For instance, if we want to substitute the predicate \(\lambda x.Q a x\) for \(P\) in the proposition we get and, using \(\beta\)-reduction, In summary, simple type theory forbids self-application but not the circularity present in impredicative definitions. The \(\lambda\)-calculus formalism also allows for a clearer analysis of Russell’s paradox. We can see it as the definition of the predicate If we think of \(\beta\)-reduction as the process of unfolding a definition, we see that there is a problem already with understanding the definition of R R In some sense, we have a non-wellfounded definition, which is as problematic as a contradiction (a proposition equivalent to its negation). One important theorem, the normalisation theorem, says that this cannot happen with simple types: if we have \(M:A\) then \(M\) is normalisable in a strong way (any sequence of reductions starting from \(M\) terminates). For more information on this topic, we refer to the entry on Church’s simple type theory.